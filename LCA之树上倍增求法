#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=5e5+100;
int st[N][20];
vector<int> g[N];
int n,m,rt;
int dep[N];
int power;
void dfs(int u,int p)//树上倍增
{
    if(u==rt) dep[u]=1;
    else dep[u]=dep[p]+1;
    st[u][0]=p;
    for(int i=1;i<=power;i++)
    {
        st[u][i]=st[st[u][i-1]][i-1];
    }
    if(g[u].size() == 1 && g[u][0]==p) return;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(v!=p) dfs(v,u);
    }

}
int lca(int a,int b)
{
    if(dep[a]<dep[b]) swap(a,b);//谁的层大谁用a变量接着
    //把a弄到和b同层
    for(int i=power;i>=0;i--)
    {
        if(dep[st[a][i]]>=dep[b]) 
        {
            a=st[a][i];
        }
    }
    if(a==b) return b;//如果把a弄到和b同层后a==b说明他们两个的最近公共祖先就是b
    //他们两个开始一起跳 只有跳到位置的节点不同 才跳
    for(int i=power;i>=0;i--)
    {
        if(st[a][i]!=st[b][i]) 
        {
            a=st[a][i];
            b=st[b][i];
        }
    }
    return st[a][0];//因为一直找的都是不同的 所以最后哦只需在跳一步
}


signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>rt;
    power=log2(n);
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    dfs(rt,0);
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        cout<<lca(a,b)<<endl;
    }

    return 0;
}
