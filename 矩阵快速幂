void init(vc<vc<int>> &a, int x = 0) // 0 0矩阵 1 单位矩阵
{
    for (int i = 1; i < a.size(); i++)
    {
        for (int j = 1; j < a[i].size(); j++)
        {
            a[i][j] = 0;
            if (i == j)
                a[i][j] = x;
        }
    }
}
void mult(vc<vc<int>> &res, vc<vc<int>> a, vc<vc<int>> b)
{
    init(res, 0);
    int n = res.size();
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < n; j++)
        {
            for (int k = 1; k < n; k++)
            {
                (res[i][j] += a[i][k] * b[k][j] % mod) %= mod;
            }
        }
    }
}

void mksm(vc<vc<int>> &res, vc<vc<int>> &a, int k) // 和快速幂思想一样
{
    init(res, 1);
    while (k)
    {
        if (k & 1)
        {
            mult(res, a, res);
        }
        k >>= 1;
        mult(a, a, a);
    }
}

inline void AC()
{
    int n, k;
    cin >> n >> k;
    vc<vc<int>> a(n + 1, vc<int>(n + 1));
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
            cin >> a[i][j];
    }
    vc<vc<int>> res(n + 1, vc<int>(n + 1));
    mksm(res, a, k);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cout << res[i][j] << ' ';
        }
        cout << endl;
    }
    return;
}
