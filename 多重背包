//二进制优化多重背包
    cin >> n >> m;
    vc<int> w;
    w.pb(0);
    auto v = w;
    for (int i = 1; i <= n; i++)
    {
        int ww, vv, s;
        cin >> ww >> vv >> s;
        int k = 1;
        while (s >= k)
        {
            v.pb(k * vv);
            w.pb(k * ww);
            s -= k;
            k <<= 1;
        }
        if (s > 0)
        {
            v.pb(s * vv);
            w.pb(s * ww);
        }
    }
    vc<int> f(m + 1);
    for (int i = 1; i < w.size(); i++)
    {
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]); 
        }
    }
    cout << f[m] << endl;
//单调队列优化多重背包
void AC()
{
    int n, m;
    cin >> n >> m;
    vc<int> w(n + 1);
    vc<int> v(n + 1);
    vc<int> s(n + 1);
    for (int i = 1; i <= n; i++)
    {
        cin >> w[i] >> v[i] >> s[i];
    }
    vc<int> f(m + 1);
    auto get = [&](int i, int j) // 获取在单调队列里面的值
    {
        return f[j] - j / v[i] * w[i];  // 为什么要这样写呢？ 因为每个位置不仅和当前的值有关 还和位置有关 应该减去位置带来的偏移量
    };
    for (int i = 1; i <= n; i++)
    {
        for (int mod = 0; mod <= min(m, v[i] - 1); mod++) // 按余数分类
        {
            deque<int> q;
            for (int j = m - mod, cnt = 1; j >= 0 && cnt <= s[i]; j -= v[i], cnt++) // 先进去这些数量个
            {
                while (q.size() && get(i, q.back()) <= get(i, j))
                {
                    q.pop_back();
                }
                q.push_back(j);
            }
            //Q:为什么前面进去了s[i]个了 刚进循环又要再进来一个 
            //A:因为j这个位置可以从 -0 -v[i] -2*v[i] .. -s[i]*v[i] 中选择一个 s[i]+1个数字
            for (int j = m - mod, ch = j - v[i] * s[i]; j >= 0; j -= v[i], ch -= v[i]) // 到着往后来
            {
                if (ch >= 0)
                {
                    while (q.size() && get(i, q.back()) <= get(i, ch))
                    {
                        q.pop_back();
                    }
                    q.pb(ch);
                }

                f[j] = get(i, q.front()) + j / v[i] * w[i]; // 加上被减去的偏移量 以及 来到现有位置应该加的
                // 为什么不去max 因为单调队列中以及包含f[j]了
                //这里一定要取get 要不再加上偏移量就算多了 
                if (q.front() == j) // 只有队头是j 才会移除 因为j要么是对头要么已经被去除了
                {
                    q.pop_front();
                }
            }
        }
    }
    cout << f[m] << endl;
}
